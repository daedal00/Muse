package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/daedal00/muse/backend/auth"
	"github.com/daedal00/muse/backend/graph/model"
	"github.com/daedal00/muse/backend/internal/models"
	redisrepo "github.com/daedal00/muse/backend/internal/repository/redis"
	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	spotifyapi "github.com/zmb3/spotify/v2"
)

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string, email string, password string) (*model.User, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreateUser started - Email: %s, Name: %s", email, name)

	// 1. Hash password
	hash, err := auth.HashPassword(password)
	if err != nil {
		log.Printf("[MUTATION] CreateUser failed - Password hashing error: %v", err)
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 2. Create database user model
	dbUser := &models.User{
		ID:           uuid.New(),
		Name:         name,
		Email:        email,
		PasswordHash: hash,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	// 3. Store in database
	if err := r.repos.User.Create(ctx, dbUser); err != nil {
		log.Printf("[MUTATION] CreateUser failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreateUser completed - UserID: %s, Duration: %v", dbUser.ID, duration)

	// 4. Convert to GraphQL model and return
	return dbUserToGraphQL(dbUser), nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	start := time.Now()
	log.Printf("[MUTATION] Login started - Email: %s", email)

	// 1) Look up user in database
	dbUser, err := r.repos.User.GetByEmail(ctx, email)
	if err != nil {
		log.Printf("[MUTATION] Login failed - User not found: %s", email)
		return "", fmt.Errorf("invalid credentials")
	}

	// 2) Verify password against stored hash
	if !auth.VerifyPassword(password, dbUser.PasswordHash) {
		log.Printf("[MUTATION] Login failed - Invalid password for user: %s", email)
		return "", fmt.Errorf("invalid credentials")
	}

	// 3) Sign JWT Token
	claims := auth.CustomClaims{
		UserID: dbUser.ID.String(),
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			Issuer:    "muse-backend",
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signedToken, err := token.SignedString([]byte(r.config.JWTSecret))
	if err != nil {
		log.Printf("[MUTATION] Login failed - Token signing error: %v", err)
		return "", fmt.Errorf("could not sign token: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] Login completed - UserID: %s, Duration: %v", dbUser.ID, duration)

	// 4) Return JWT token
	return signedToken, nil
}

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.CreateReviewInput) (*model.Review, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreateReview started - AlbumID: %s, Rating: %d", input.AlbumID, input.Rating)

	// 1) Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[MUTATION] CreateReview failed - Unauthenticated request")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[MUTATION] CreateReview - UserID: %s", currentUserID)

	// Parse current user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[MUTATION] CreateReview failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Parse album ID
	albumID, err := uuid.Parse(input.AlbumID)
	if err != nil {
		log.Printf("[MUTATION] CreateReview failed - Invalid album ID: %s", input.AlbumID)
		return nil, fmt.Errorf("invalid album ID")
	}

	// Validate rating range
	if input.Rating < 1 || input.Rating > 5 {
		log.Printf("[MUTATION] CreateReview failed - Invalid rating: %d", input.Rating)
		return nil, fmt.Errorf("rating must be between 1 and 5")
	}

	// Create database review model
	dbReview := &models.Review{
		ID:         uuid.New(),
		UserID:     userID,
		AlbumID:    albumID,
		Rating:     int(input.Rating),
		ReviewText: input.ReviewText,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	// Store in database using review repository
	if err := r.repos.Review.Create(ctx, dbReview); err != nil {
		log.Printf("[MUTATION] CreateReview failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create review: %w", err)
	}

	// Cache this album as recently viewed by the user (async, don't fail on error)
	go func() {
		// Create a background context for the cache operation
		cacheCtx := context.Background()

		// Get album tracks for more complete cache data
		tracks, trackErr := r.repos.Track.GetByAlbumID(cacheCtx, albumID, 50, 0)
		if trackErr == nil && len(tracks) > 0 {
			// Add the first track as recently played (representing album interaction)
			if err := r.repos.MusicCache.AddToRecentlyPlayed(cacheCtx, userID, tracks[0]); err != nil {
				// Log the error but don't fail the mutation
				log.Printf("[CACHE] Warning: Failed to add track to recently played: %v", err)
			}
		}
	}()

	// Convert to GraphQL model
	graphqlReview := dbReviewToGraphQL(dbReview)

	// Publish to subscription manager for real-time updates
	if err := r.subscriptionMgr.PublishReview(ctx, graphqlReview); err != nil {
		// Log error but don't fail the mutation
		log.Printf("[SUBSCRIPTION] Warning: Failed to publish review to subscribers: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreateReview completed - ReviewID: %s, Duration: %v", dbReview.ID, duration)

	return graphqlReview, nil
}

// CreatePlaylist is the resolver for the createPlaylist field.
func (r *mutationResolver) CreatePlaylist(ctx context.Context, input model.CreatePlaylistInput) (*model.Playlist, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreatePlaylist started - Title: %s", input.Title)

	// 1) Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Unauthenticated request")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[MUTATION] CreatePlaylist - UserID: %s", currentUserID)

	// Parse current user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Validate input
	if input.Title == "" {
		log.Printf("[MUTATION] CreatePlaylist failed - Empty title")
		return nil, fmt.Errorf("playlist title cannot be empty")
	}

	// Create database playlist model
	dbPlaylist := &models.Playlist{
		ID:          uuid.New(),
		Title:       input.Title,
		Description: input.Description,
		CoverImage:  input.CoverImage,
		CreatorID:   userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Store in database using playlist repository
	if err := r.repos.Playlist.Create(ctx, dbPlaylist); err != nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create playlist: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreatePlaylist completed - PlaylistID: %s, Duration: %v", dbPlaylist.ID, duration)

	// Convert to GraphQL model and return
	return dbPlaylistToGraphQL(dbPlaylist), nil
}

// AddTrackToPlaylist is the resolver for the addTrackToPlaylist field.
func (r *mutationResolver) AddTrackToPlaylist(ctx context.Context, playlistID string, trackID string) (*model.Playlist, error) {
	// Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)

	// Parse IDs
	pID, err := uuid.Parse(playlistID)
	if err != nil {
		return nil, fmt.Errorf("invalid playlist ID")
	}

	tID, err := uuid.Parse(trackID)
	if err != nil {
		return nil, fmt.Errorf("invalid track ID")
	}

	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Verify playlist exists and user has permission
	dbPlaylist, err := r.repos.Playlist.GetByID(ctx, pID)
	if err != nil {
		return nil, fmt.Errorf("playlist not found: %w", err)
	}

	if dbPlaylist.CreatorID != userID {
		return nil, fmt.Errorf("unauthorized: you can only modify your own playlists")
	}

	// Verify track exists
	_, err = r.repos.Track.GetByID(ctx, tID)
	if err != nil {
		return nil, fmt.Errorf("track not found: %w", err)
	}

	// Add track to playlist (position 0 means append to end)
	err = r.repos.Playlist.AddTrack(ctx, pID, tID, 0)
	if err != nil {
		return nil, fmt.Errorf("failed to add track to playlist: %w", err)
	}

	// Return updated playlist
	updatedPlaylist, err := r.repos.Playlist.GetByID(ctx, pID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch updated playlist: %w", err)
	}

	return dbPlaylistToGraphQL(updatedPlaylist), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	start := time.Now()
	log.Printf("[QUERY] Me started")

	// Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[QUERY] Me failed - Unauthenticated request")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[QUERY] Me - UserID: %s", currentUserID)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[QUERY] Me failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Look up user in database
	dbUser, err := r.repos.User.GetByID(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] Me failed - Database error: %v", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Me completed - UserID: %s, Duration: %v", userID, duration)

	return dbUserToGraphQL(dbUser), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	start := time.Now()
	log.Printf("[QUERY] User started - ID: %s", id)

	// Parse user ID
	userID, err := uuid.Parse(id)
	if err != nil {
		log.Printf("[QUERY] User failed - Invalid user ID: %s", id)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Look up user in database
	dbUser, err := r.repos.User.GetByID(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] User failed - Database error: %v", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] User completed - UserID: %s, Duration: %v", userID, duration)

	return dbUserToGraphQL(dbUser), nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context, first *int32, after *string) (*model.AlbumConnection, error) {
	start := time.Now()
	var limit int32 = 10
	if first != nil {
		limit = *first
	}
	log.Printf("[QUERY] Albums started - Limit: %d, After: %v", limit, after)

	// Set default limit
	limitInt := int(limit)

	// Use pagination helper for improved cursor-based pagination
	albums, hasNextPage, err := r.paginationHelper.GetAlbumsWithCursor(ctx, limitInt, after)
	if err != nil {
		log.Printf("[QUERY] Albums failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to fetch albums: %w", err)
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.AlbumEdge, len(albums))
	for i, album := range albums {
		edges[i] = &model.AlbumEdge{
			Cursor: r.paginationHelper.EncodeCursor(album.ID.String(), album.CreatedAt, i),
			Node:   dbAlbumToGraphQL(album),
		}
	}

	// Get total count for the connection
	totalCount := len(edges) // Simplified total count using current page size

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Albums completed - Count: %d, HasNext: %t, Duration: %v", len(albums), hasNextPage, duration)

	return &model.AlbumConnection{
		TotalCount: safeLenToInt32(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	start := time.Now()
	log.Printf("[QUERY] Album started - ID: %s", id)

	albumID, err := uuid.Parse(id)
	if err != nil {
		log.Printf("[QUERY] Album failed - Invalid album ID: %s", id)
		return nil, fmt.Errorf("invalid album ID")
	}

	dbAlbum, err := r.repos.Album.GetByID(ctx, albumID)
	if err != nil {
		log.Printf("[QUERY] Album failed - Database error: %v", err)
		return nil, fmt.Errorf("album not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Album completed - AlbumID: %s, Duration: %v", albumID, duration)

	return dbAlbumToGraphQL(dbAlbum), nil
}

// Tracks is the resolver for the tracks field.
func (r *queryResolver) Tracks(ctx context.Context, first *int32, after *string) (*model.TrackConnection, error) {
	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Use pagination helper for improved cursor-based pagination
	tracks, hasNextPage, err := r.paginationHelper.GetTracksWithCursor(ctx, limit, after)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch tracks: %w", err)
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.TrackEdge, len(tracks))
	for i, track := range tracks {
		edges[i] = &model.TrackEdge{
			Cursor: r.paginationHelper.EncodeCursor(track.ID.String(), track.CreatedAt, i),
			Node:   dbTrackToGraphQL(track),
		}
	}

	// Get total count for the connection
	totalCount := len(edges) // Simplified total count using current page size

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.TrackConnection{
		TotalCount: safeLenToInt32(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Track is the resolver for the track field.
func (r *queryResolver) Track(ctx context.Context, id string) (*model.Track, error) {
	trackID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid track ID")
	}

	dbTrack, err := r.repos.Track.GetByID(ctx, trackID)
	if err != nil {
		return nil, fmt.Errorf("track not found: %w", err)
	}

	return dbTrackToGraphQL(dbTrack), nil
}

// Playlists is the resolver for the playlists field.
func (r *queryResolver) Playlists(ctx context.Context, first *int32, after *string) (*model.PlaylistConnection, error) {
	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Use pagination helper for improved cursor-based pagination
	playlists, hasNextPage, err := r.paginationHelper.GetPlaylistsWithCursor(ctx, limit, after)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch playlists: %w", err)
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.PlaylistEdge, len(playlists))
	for i, playlist := range playlists {
		edges[i] = &model.PlaylistEdge{
			Cursor: r.paginationHelper.EncodeCursor(playlist.ID.String(), playlist.CreatedAt, i),
			Node:   dbPlaylistToGraphQL(playlist),
		}
	}

	// Get total count for the connection
	totalCount := len(edges) // Simplified total count using current page size

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.PlaylistConnection{
		TotalCount: safeLenToInt32(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Playlist is the resolver for the playlist field.
func (r *queryResolver) Playlist(ctx context.Context, id string) (*model.Playlist, error) {
	playlistID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid playlist ID")
	}

	dbPlaylist, err := r.repos.Playlist.GetByID(ctx, playlistID)
	if err != nil {
		return nil, fmt.Errorf("playlist not found: %w", err)
	}

	return dbPlaylistToGraphQL(dbPlaylist), nil
}

// Reviews is the resolver for the reviews field.
func (r *queryResolver) Reviews(ctx context.Context, first *int32, after *string) (*model.ReviewConnection, error) {
	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Use pagination helper for improved cursor-based pagination
	reviews, hasNextPage, err := r.paginationHelper.GetReviewsWithCursor(ctx, limit, after)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch reviews: %w", err)
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.ReviewEdge, len(reviews))
	for i, review := range reviews {
		edges[i] = &model.ReviewEdge{
			Cursor: r.paginationHelper.EncodeCursor(review.ID.String(), review.CreatedAt, i),
			Node:   dbReviewToGraphQL(review),
		}
	}

	// Get total count for the connection
	totalCount := len(edges) // Simplified total count using current page size

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.ReviewConnection{
		TotalCount: safeLenToInt32(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, id string) (*model.Review, error) {
	reviewID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid review ID")
	}

	dbReview, err := r.repos.Review.GetByID(ctx, reviewID)
	if err != nil {
		return nil, fmt.Errorf("review not found: %w", err)
	}

	return dbReviewToGraphQL(dbReview), nil
}

// RecentlyPlayed is the resolver for the recentlyPlayed field.
func (r *queryResolver) RecentlyPlayed(ctx context.Context, limit *int32) ([]*model.Track, error) {
	// Extract UserID from Context (must be authenticated)
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Get cached music data
	cachedData, err := r.repos.MusicCache.GetUserMusicData(ctx, userID)
	if err != nil {
		return nil, fmt.Errorf("failed to get user music data: %w", err)
	}

	if cachedData == nil {
		// No cached data, return empty list
		return []*model.Track{}, nil
	}

	// Cast to MusicData
	musicData, ok := cachedData.(*redisrepo.MusicData)
	if !ok {
		return nil, fmt.Errorf("invalid cached data format")
	}

	// Apply limit if specified
	recentlyPlayed := musicData.RecentlyPlayed
	if limit != nil && len(recentlyPlayed) > int(*limit) {
		recentlyPlayed = recentlyPlayed[:int(*limit)]
	}

	// Convert database models to GraphQL models
	tracks := make([]*model.Track, len(recentlyPlayed))
	for i, track := range recentlyPlayed {
		tracks[i] = dbTrackToGraphQL(track)
	}

	return tracks, nil
}

// SearchAlbums is the resolver for the searchAlbums field.
func (r *queryResolver) SearchAlbums(ctx context.Context, input model.AlbumSearchInput) ([]*model.AlbumSearchResult, error) {
	start := time.Now()
	limit := 20
	if input.Limit != nil {
		limit = int(*input.Limit)
	}
	log.Printf("[QUERY] SearchAlbums started - Query: '%s', Limit: %d, Source: %s", input.Query, limit, input.Source)

	if r.spotifyServices == nil {
		log.Printf("[QUERY] SearchAlbums failed - Spotify service not available")
		return nil, fmt.Errorf("Spotify service not available")
	}

	// Check cache first
	cacheKey := fmt.Sprintf("%s:%d", input.Query, limit)
	log.Printf("[CACHE] Checking cache for albums - Key: %s", cacheKey)

	if cachedData, err := r.repos.MusicCache.GetSearchResults(ctx, cacheKey, "albums"); err == nil && cachedData != nil {
		if searchData, ok := cachedData.(*redisrepo.SearchCacheData); ok {
			if results, ok := searchData.Results.([]*model.AlbumSearchResult); ok {
				duration := time.Since(start)
				log.Printf("[QUERY] SearchAlbums completed (CACHE HIT) - Query: '%s', Count: %d, Duration: %v", input.Query, len(results), duration)
				return results, nil
			}
		}
	}
	log.Printf("[CACHE] Cache miss for albums - Key: %s", cacheKey)

	// Use the new Spotify client to search for albums
	log.Printf("[SPOTIFY] Calling Spotify API for albums - Query: '%s', Limit: %d", input.Query, limit)
	results, err := r.spotifyServices.Search.SearchAlbums(ctx, input.Query,
		spotifyapi.Limit(limit))
	if err != nil {
		log.Printf("[SPOTIFY] SearchAlbums failed - API error: %v", err)
		return nil, fmt.Errorf("failed to search albums: %w", err)
	}

	log.Printf("[SPOTIFY] Spotify API response received - Albums found: %d", len(results.Albums.Albums))

	// Convert Spotify results to GraphQL model
	var albumResults []*model.AlbumSearchResult
	if results.Albums != nil {
		for _, album := range results.Albums.Albums {
			// Convert artists
			var artists []*model.ArtistSearchResult
			for _, artist := range album.Artists {
				artists = append(artists, &model.ArtistSearchResult{
					ID:             string(artist.ID),
					Name:           artist.Name,
					ExternalSource: model.ExternalSourceSpotify,
				})
			}

			// Convert release date
			var releaseDate *string
			if album.ReleaseDate != "" {
				releaseDate = &album.ReleaseDate
			}

			// Convert cover image
			var coverImage *string
			if len(album.Images) > 0 {
				coverImage = &album.Images[0].URL
			}

			albumResults = append(albumResults, &model.AlbumSearchResult{
				ID:             string(album.ID),
				Title:          album.Name,
				Artist:         artists,
				ReleaseDate:    releaseDate,
				CoverImage:     coverImage,
				ExternalSource: model.ExternalSourceSpotify,
			})
		}
	}

	// Cache the results for faster future searches
	log.Printf("[CACHE] Caching album search results - Key: %s, Count: %d", cacheKey, len(albumResults))
	if err := r.repos.MusicCache.SetSearchResults(ctx, cacheKey, "albums", albumResults); err != nil {
		// Log the error but don't fail the request
		log.Printf("[CACHE] Warning: Failed to cache album search results: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] SearchAlbums completed (SPOTIFY API) - Query: '%s', Count: %d, Duration: %v", input.Query, len(albumResults), duration)

	return albumResults, nil
}

// SearchArtists is the resolver for the searchArtists field.
func (r *queryResolver) SearchArtists(ctx context.Context, input model.ArtistSearchInput) ([]*model.ArtistSearchResult, error) {
	start := time.Now()
	limit := 20
	if input.Limit != nil {
		limit = int(*input.Limit)
	}
	log.Printf("[QUERY] SearchArtists started - Query: '%s', Limit: %d, Source: %s", input.Query, limit, input.Source)

	if r.spotifyServices == nil {
		log.Printf("[QUERY] SearchArtists failed - Spotify service not available")
		return nil, fmt.Errorf("spotify service not available")
	}

	// Check cache first
	cacheKey := fmt.Sprintf("%s:%d", input.Query, limit)
	log.Printf("[CACHE] Checking cache for artists - Key: %s", cacheKey)

	if cachedData, err := r.repos.MusicCache.GetSearchResults(ctx, cacheKey, "artists"); err == nil && cachedData != nil {
		if searchData, ok := cachedData.(*redisrepo.SearchCacheData); ok {
			if results, ok := searchData.Results.([]*model.ArtistSearchResult); ok {
				duration := time.Since(start)
				log.Printf("[QUERY] SearchArtists completed (CACHE HIT) - Query: '%s', Count: %d, Duration: %v", input.Query, len(results), duration)
				return results, nil
			}
		}
	}
	log.Printf("[CACHE] Cache miss for artists - Key: %s", cacheKey)

	// Use the new Spotify client to search for artists
	log.Printf("[SPOTIFY] Calling Spotify API for artists - Query: '%s', Limit: %d", input.Query, limit)
	results, err := r.spotifyServices.Search.SearchArtists(ctx, input.Query,
		spotifyapi.Limit(limit))
	if err != nil {
		log.Printf("[SPOTIFY] SearchArtists failed - API error: %v", err)
		return nil, fmt.Errorf("failed to search artists: %w", err)
	}

	log.Printf("[SPOTIFY] Spotify API response received - Artists found: %d", len(results.Artists.Artists))

	// Convert Spotify results to GraphQL model
	var artistResults []*model.ArtistSearchResult
	if results.Artists != nil {
		for _, artist := range results.Artists.Artists {
			artistResults = append(artistResults, &model.ArtistSearchResult{
				ID:             string(artist.ID),
				Name:           artist.Name,
				ExternalSource: model.ExternalSourceSpotify,
			})
		}
	}

	// Cache the results for faster future searches
	log.Printf("[CACHE] Caching artist search results - Key: %s, Count: %d", cacheKey, len(artistResults))
	if err := r.repos.MusicCache.SetSearchResults(ctx, cacheKey, "artists", artistResults); err != nil {
		// Log the error but don't fail the request
		log.Printf("[CACHE] Warning: Failed to cache artist search results: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] SearchArtists completed (SPOTIFY API) - Query: '%s', Count: %d, Duration: %v", input.Query, len(artistResults), duration)

	return artistResults, nil
}

// ReviewAdded is the resolver for the reviewAdded field.
func (r *subscriptionResolver) ReviewAdded(ctx context.Context, albumID string) (<-chan *model.Review, error) {
	// Subscribe to review updates for the specified album using subscription manager
	reviewChan, cleanup := r.subscriptionMgr.Subscribe(ctx, albumID)

	// The cleanup function will be called automatically when the context is cancelled
	_ = cleanup

	return reviewChan, nil
}

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

type mutationResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
