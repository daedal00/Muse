package graph

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.75

import (
	"context"
	"fmt"
	"log"
	"time"

	"github.com/daedal00/muse/backend/auth"
	"github.com/daedal00/muse/backend/graph/model"
	"github.com/daedal00/muse/backend/internal/models"
	redisrepo "github.com/daedal00/muse/backend/internal/repository/redis"
	jwt "github.com/golang-jwt/jwt/v5"
	"github.com/google/uuid"
	spotifyapi "github.com/zmb3/spotify/v2"
)

// Albums is the resolver for the albums field.
func (r *artistResolver) Albums(ctx context.Context, obj *model.Artist) (*model.AlbumConnection, error) {
	start := time.Now()
	log.Printf("[RESOLVER] Artist.Albums started - ArtistID: %s", obj.ID)

	if r.spotifyServices == nil {
		log.Printf("[RESOLVER] Artist.Albums - Spotify service not available")
		return &model.AlbumConnection{
			TotalCount: 0,
			Edges:      []*model.AlbumEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	// Fetch artist's albums from Spotify API
	albumTypes := []spotifyapi.AlbumType{spotifyapi.AlbumTypeAlbum, spotifyapi.AlbumTypeSingle}
	albumsPage, err := r.spotifyServices.Artist.GetArtistAlbums(ctx, spotifyapi.ID(obj.ID), albumTypes, spotifyapi.Limit(20))
	if err != nil {
		log.Printf("[RESOLVER] Artist.Albums - Spotify API error: %v", err)
		return &model.AlbumConnection{
			TotalCount: 0,
			Edges:      []*model.AlbumEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	// Convert albums to GraphQL models
	var edges []*model.AlbumEdge
	for i, album := range albumsPage.Albums {
		// Convert album artists
		var albumArtists []models.SpotifyArtist
		for _, artist := range album.Artists {
			albumArtists = append(albumArtists, models.SpotifyArtist{
				ID:   string(artist.ID),
				Name: artist.Name,
			})
		}

		// Convert album images
		var images []string
		for _, image := range album.Images {
			images = append(images, image.URL)
		}

		albumModel := &models.SpotifyAlbum{
			ID:          string(album.ID),
			Name:        album.Name,
			Artists:     albumArtists,
			ReleaseDate: album.ReleaseDate,
			Images:      images,
		}

		// Cache the album
		if err := r.repos.SpotifyCache.SetAlbum(ctx, albumModel); err != nil {
			log.Printf("[CACHE] Warning: Failed to cache album: %v", err)
		}

		albumGraphQL := spotifyAlbumToGraphQL(albumModel)
		edges = append(edges, &model.AlbumEdge{
			Cursor: r.paginationHelper.EncodeCursor(string(album.ID), time.Now(), i),
			Node:   albumGraphQL,
		})
	}

	duration := time.Since(start)
	log.Printf("[RESOLVER] Artist.Albums completed - ArtistID: %s, Count: %d, Duration: %v", obj.ID, len(edges), duration)

	return &model.AlbumConnection{
		TotalCount: int32(len(edges)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   nil,
			HasNextPage: albumsPage.Next != "",
		},
	}, nil
}

// CreateUser is the resolver for the createUser field.
func (r *mutationResolver) CreateUser(ctx context.Context, name string, email string, password string) (*model.User, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreateUser started - Email: %s, Name: %s", email, name)

	// 1. Hash password
	hash, err := auth.HashPassword(password)
	if err != nil {
		log.Printf("[MUTATION] CreateUser failed - Password hashing error: %v", err)
		return nil, fmt.Errorf("failed to hash password: %w", err)
	}

	// 2. Create database user model
	dbUser := &models.User{
		ID:           uuid.New(),
		Name:         name,
		Email:        email,
		PasswordHash: hash,
		CreatedAt:    time.Now(),
		UpdatedAt:    time.Now(),
	}

	// 3. Store in database
	if err := r.repos.User.Create(ctx, dbUser); err != nil {
		log.Printf("[MUTATION] CreateUser failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create user: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreateUser completed - UserID: %s, Duration: %v", dbUser.ID, duration)

	// 4. Convert to GraphQL model and return
	return dbUserToGraphQL(dbUser), nil
}

// Login is the resolver for the login field.
func (r *mutationResolver) Login(ctx context.Context, email string, password string) (string, error) {
	start := time.Now()
	log.Printf("[MUTATION] Login started - Email: %s", email)

	// 1) Look up user in database
	dbUser, err := r.repos.User.GetByEmail(ctx, email)
	if err != nil {
		log.Printf("[MUTATION] Login failed - User not found: %s", email)
		return "", fmt.Errorf("invalid credentials")
	}

	// 2) Verify password against stored hash
	if !auth.VerifyPassword(password, dbUser.PasswordHash) {
		log.Printf("[MUTATION] Login failed - Invalid password for user: %s", email)
		return "", fmt.Errorf("invalid credentials")
	}

	// 3) Sign JWT Token
	claims := auth.CustomClaims{
		UserID: dbUser.ID.String(),
		RegisteredClaims: jwt.RegisteredClaims{
			ExpiresAt: jwt.NewNumericDate(time.Now().Add(24 * time.Hour)),
			IssuedAt:  jwt.NewNumericDate(time.Now()),
			Issuer:    "muse-backend",
		},
	}
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, claims)
	signedToken, err := token.SignedString([]byte(r.config.JWTSecret))
	if err != nil {
		log.Printf("[MUTATION] Login failed - Token signing error: %v", err)
		return "", fmt.Errorf("could not sign token: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] Login completed - UserID: %s, Duration: %v", dbUser.ID, duration)

	// 4) Return JWT token
	return signedToken, nil
}

// CreateReview is the resolver for the createReview field.
func (r *mutationResolver) CreateReview(ctx context.Context, input model.CreateReviewInput) (*model.Review, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreateReview started - AlbumID: %v, TrackID: %v, Rating: %d", input.AlbumID, input.TrackID, input.Rating)

	// Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[MUTATION] CreateReview failed - Unauthenticated")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[MUTATION] CreateReview failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Validate that either albumId or trackId is provided, but not both
	if (input.AlbumID == nil && input.TrackID == nil) || (input.AlbumID != nil && input.TrackID != nil) {
		log.Printf("[MUTATION] CreateReview failed - Invalid input: both or neither IDs provided")
		return nil, fmt.Errorf("either albumId or trackId must be provided, but not both")
	}

	// Validate rating range
	if input.Rating < 1 || input.Rating > 5 {
		log.Printf("[MUTATION] CreateReview failed - Invalid rating: %d", input.Rating)
		return nil, fmt.Errorf("rating must be between 1 and 5")
	}

	// Create database review model with new schema
	dbReview := &models.Review{
		ID:         uuid.New(),
		UserID:     userID,
		Rating:     int(input.Rating),
		ReviewText: input.ReviewText,
		CreatedAt:  time.Now(),
		UpdatedAt:  time.Now(),
	}

	// Set Spotify ID and type based on input
	if input.AlbumID != nil {
		// In the new architecture, this should be a Spotify ID, not UUID
		dbReview.SpotifyID = *input.AlbumID
		dbReview.SpotifyType = "album"
		log.Printf("[MUTATION] CreateReview - Album Spotify ID: %s", *input.AlbumID)
	}

	if input.TrackID != nil {
		// In the new architecture, this should be a Spotify ID, not UUID
		dbReview.SpotifyID = *input.TrackID
		dbReview.SpotifyType = "track"
		log.Printf("[MUTATION] CreateReview - Track Spotify ID: %s", *input.TrackID)
	}

	// Store in database using review repository
	if err := r.repos.Review.Create(ctx, dbReview); err != nil {
		log.Printf("[MUTATION] CreateReview failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create review: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreateReview completed - ReviewID: %s, Duration: %v", dbReview.ID, duration)

	return dbReviewToGraphQL(dbReview), nil
}

// CreatePlaylist is the resolver for the createPlaylist field.
func (r *mutationResolver) CreatePlaylist(ctx context.Context, input model.CreatePlaylistInput) (*model.Playlist, error) {
	start := time.Now()
	log.Printf("[MUTATION] CreatePlaylist started - Title: %s", input.Title)

	// 1) Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Unauthenticated request")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[MUTATION] CreatePlaylist - UserID: %s", currentUserID)

	// Parse current user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Validate input
	if input.Title == "" {
		log.Printf("[MUTATION] CreatePlaylist failed - Empty title")
		return nil, fmt.Errorf("playlist title cannot be empty")
	}

	// Create database playlist model
	dbPlaylist := &models.Playlist{
		ID:          uuid.New(),
		Title:       input.Title,
		Description: input.Description,
		CoverImage:  input.CoverImage,
		CreatorID:   userID,
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	// Store in database using playlist repository
	if err := r.repos.Playlist.Create(ctx, dbPlaylist); err != nil {
		log.Printf("[MUTATION] CreatePlaylist failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to create playlist: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] CreatePlaylist completed - PlaylistID: %s, Duration: %v", dbPlaylist.ID, duration)

	// Convert to GraphQL model and return
	return dbPlaylistToGraphQL(dbPlaylist), nil
}

// AddTrackToPlaylist is the resolver for the addTrackToPlaylist field.
func (r *mutationResolver) AddTrackToPlaylist(ctx context.Context, playlistID string, trackID string) (*model.Playlist, error) {
	start := time.Now()
	log.Printf("[MUTATION] AddTrackToPlaylist started - PlaylistID: %s, TrackID: %s", playlistID, trackID)

	// Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[MUTATION] AddTrackToPlaylist failed - Unauthenticated")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[MUTATION] AddTrackToPlaylist failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Parse playlist ID
	playlistUUID, err := uuid.Parse(playlistID)
	if err != nil {
		log.Printf("[MUTATION] AddTrackToPlaylist failed - Invalid playlist ID: %s", playlistID)
		return nil, fmt.Errorf("invalid playlist ID")
	}

	// Add track to playlist using Spotify ID (trackID is now a Spotify ID, not UUID)
	err = r.repos.Playlist.AddTrack(ctx, playlistUUID, trackID, 0, userID)
	if err != nil {
		log.Printf("[MUTATION] AddTrackToPlaylist failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to add track to playlist: %w", err)
	}

	// Get updated playlist
	playlist, err := r.repos.Playlist.GetByID(ctx, playlistUUID)
	if err != nil {
		log.Printf("[MUTATION] AddTrackToPlaylist failed - Failed to get updated playlist: %v", err)
		return nil, fmt.Errorf("failed to get updated playlist: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[MUTATION] AddTrackToPlaylist completed - PlaylistID: %s, TrackID: %s, Duration: %v", playlistID, trackID, duration)

	return dbPlaylistToGraphQL(playlist), nil
}

// ImportSpotifyPlaylist is the resolver for the importSpotifyPlaylist field.
func (r *mutationResolver) ImportSpotifyPlaylist(ctx context.Context, spotifyPlaylistID string) (*model.Playlist, error) {
	// Get current user from context
	userIDStr, ok := ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	if r.SpotifyPlaylistService == nil {
		return nil, fmt.Errorf("spotify service not available")
	}

	// Import the playlist
	playlist, err := r.SpotifyPlaylistService.ImportSpotifyPlaylist(ctx, userID, spotifyPlaylistID)
	if err != nil {
		return nil, fmt.Errorf("failed to import playlist: %w", err)
	}

	// Convert to GraphQL model
	return dbPlaylistToGraphQL(playlist), nil
}

// Tracks is the resolver for the tracks field.
func (r *playlistResolver) Tracks(ctx context.Context, obj *model.Playlist) (*model.TrackConnection, error) {
	start := time.Now()
	log.Printf("[RESOLVER] Playlist.Tracks started - PlaylistID: %s", obj.ID)

	// Parse playlist ID
	playlistID, err := uuid.Parse(obj.ID)
	if err != nil {
		log.Printf("[RESOLVER] Playlist.Tracks failed - Invalid playlist ID: %s", obj.ID)
		return nil, fmt.Errorf("invalid playlist ID")
	}

	// Get track IDs from playlist
	trackEntries, err := r.repos.Playlist.GetPlaylistTracks(ctx, playlistID, 50, 0)
	if err != nil {
		log.Printf("[RESOLVER] Playlist.Tracks failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to get playlist tracks: %w", err)
	}

	// TODO: In new architecture, we need to fetch track details from Spotify API using the Spotify IDs
	// For now, create stub track objects
	edges := make([]*model.TrackEdge, len(trackEntries))
	for i, entry := range trackEntries {
		// Create a stub track with just the Spotify ID
		track := &model.Track{
			ID:        entry.SpotifyID,
			SpotifyID: &entry.SpotifyID,
			Title:     "Loading...", // Would be fetched from Spotify
		}

		edges[i] = &model.TrackEdge{
			Cursor: r.paginationHelper.EncodeCursor(entry.ID.String(), entry.AddedAt, i),
			Node:   track,
		}
	}

	duration := time.Since(start)
	log.Printf("[RESOLVER] Playlist.Tracks completed - PlaylistID: %s, Count: %d, Duration: %v", obj.ID, len(trackEntries), duration)

	return &model.TrackConnection{
		TotalCount: int32(len(trackEntries)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   nil,
			HasNextPage: false,
		},
	}, nil
}

// Creator is the resolver for the creator field.
func (r *playlistResolver) Creator(ctx context.Context, obj *model.Playlist) (*model.User, error) {
	// Parse playlist ID to get the creator
	playlistID, err := uuid.Parse(obj.ID)
	if err != nil {
		return nil, fmt.Errorf("invalid playlist ID")
	}

	// Get playlist with creator
	playlist, err := r.repos.Playlist.GetByID(ctx, playlistID)
	if err != nil {
		return nil, fmt.Errorf("failed to get playlist: %w", err)
	}

	if playlist.Creator == nil {
		return nil, fmt.Errorf("playlist creator not found")
	}

	return dbUserToGraphQL(playlist.Creator), nil
}

// Playlist is the resolver for the playlist field.
func (r *queryResolver) Playlist(ctx context.Context, id string) (*model.Playlist, error) {
	playlistID, err := uuid.Parse(id)
	if err != nil {
		return nil, fmt.Errorf("invalid playlist ID")
	}

	dbPlaylist, err := r.repos.Playlist.GetByID(ctx, playlistID)
	if err != nil {
		return nil, fmt.Errorf("playlist not found: %w", err)
	}

	return dbPlaylistToGraphQL(dbPlaylist), nil
}

// Reviews is the resolver for the reviews field.
func (r *queryResolver) Reviews(ctx context.Context, first *int32, after *string) (*model.ReviewConnection, error) {
	start := time.Now()
	log.Printf("[QUERY] Reviews started")

	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Get reviews with pagination
	reviews, err := r.repos.Review.List(ctx, limit+1, 0)
	if err != nil {
		log.Printf("[QUERY] Reviews failed - Database error: %v", err)
		return nil, fmt.Errorf("failed to get reviews: %w", err)
	}

	// Check if there's a next page
	hasNextPage := len(reviews) > limit
	if hasNextPage {
		reviews = reviews[:limit]
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.ReviewEdge, len(reviews))
	for i, review := range reviews {
		edges[i] = &model.ReviewEdge{
			Cursor: r.paginationHelper.EncodeCursor(review.ID.String(), review.CreatedAt, i),
			Node:   dbReviewToGraphQL(review),
		}
	}

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Reviews completed - Count: %d, Duration: %v", len(reviews), duration)

	return &model.ReviewConnection{
		TotalCount: int32(len(reviews)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// Review is the resolver for the review field.
func (r *queryResolver) Review(ctx context.Context, id string) (*model.Review, error) {
	start := time.Now()
	log.Printf("[QUERY] Review started - ID: %s", id)

	reviewID, err := uuid.Parse(id)
	if err != nil {
		log.Printf("[QUERY] Review failed - Invalid review ID: %s", id)
		return nil, fmt.Errorf("invalid review ID")
	}

	dbReview, err := r.repos.Review.GetByID(ctx, reviewID)
	if err != nil {
		log.Printf("[QUERY] Review failed - Review not found: %s", id)
		return nil, fmt.Errorf("review not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Review completed - ID: %s, Duration: %v", id, duration)

	return dbReviewToGraphQL(dbReview), nil
}

// Me is the resolver for the me field.
func (r *queryResolver) Me(ctx context.Context) (*model.User, error) {
	start := time.Now()
	log.Printf("[QUERY] Me started")

	// Extract UserID from Context
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[QUERY] Me failed - Unauthenticated request")
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[QUERY] Me - UserID: %s", currentUserID)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		log.Printf("[QUERY] Me failed - Invalid user ID: %s", currentUserID)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Look up user in database
	dbUser, err := r.repos.User.GetByID(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] Me failed - Database error: %v", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Me completed - UserID: %s, Duration: %v", userID, duration)

	return dbUserToGraphQL(dbUser), nil
}

// User is the resolver for the user field.
func (r *queryResolver) User(ctx context.Context, id string) (*model.User, error) {
	start := time.Now()
	log.Printf("[QUERY] User started - ID: %s", id)

	// Parse user ID
	userID, err := uuid.Parse(id)
	if err != nil {
		log.Printf("[QUERY] User failed - Invalid user ID: %s", id)
		return nil, fmt.Errorf("invalid user ID")
	}

	// Look up user in database
	dbUser, err := r.repos.User.GetByID(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] User failed - Database error: %v", err)
		return nil, fmt.Errorf("user not found: %w", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] User completed - UserID: %s, Duration: %v", userID, duration)

	return dbUserToGraphQL(dbUser), nil
}

// Albums is the resolver for the albums field.
func (r *queryResolver) Albums(ctx context.Context, first *int32, after *string) (*model.AlbumConnection, error) {
	start := time.Now()
	log.Printf("[QUERY] Albums started")

	// Extract UserID from Context (must be authenticated for user-specific data)
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[QUERY] Albums - User not authenticated, returning empty connection")
		return &model.AlbumConnection{
			TotalCount: 0,
			Edges:      []*model.AlbumEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	currentUserID := raw.(string)
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Try to get user's saved albums from cache
	cachedData, err := r.repos.SpotifyCache.GetUserData(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] Albums - Cache error: %v", err)
		// Return empty list instead of error for better UX
		return &model.AlbumConnection{
			TotalCount: 0,
			Edges:      []*model.AlbumEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	if cachedData == nil || len(cachedData.SavedAlbums) == 0 {
		log.Printf("[QUERY] Albums - No saved albums for user")
		return &model.AlbumConnection{
			TotalCount: 0,
			Edges:      []*model.AlbumEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	// Get album details from cache or Spotify API
	var edges []*model.AlbumEdge
	limit := 20
	if first != nil {
		limit = int(*first)
	}

	albumIDs := cachedData.SavedAlbums
	if len(albumIDs) > limit {
		albumIDs = albumIDs[:limit]
	}

	for i, albumID := range albumIDs {
		// Try cache first
		cachedAlbum, err := r.repos.SpotifyCache.GetAlbum(ctx, albumID)
		if err == nil && cachedAlbum != nil {
			albumGraphQL := spotifyAlbumToGraphQL(cachedAlbum)
			edges = append(edges, &model.AlbumEdge{
				Cursor: r.paginationHelper.EncodeCursor(albumID, time.Now(), i),
				Node:   albumGraphQL,
			})
			continue
		}

		// Fallback to Spotify API
		if r.spotifyServices != nil {
			spotifyAlbum, err := r.spotifyServices.Album.GetAlbum(ctx, spotifyapi.ID(albumID))
			if err == nil {
				albumModel := spotifyAPIAlbumToModel(spotifyAlbum)
				// Cache the result
				if err := r.repos.SpotifyCache.SetAlbum(ctx, albumModel); err != nil {
					log.Printf("[CACHE] Warning: Failed to cache album: %v", err)
				}
				albumGraphQL := spotifyAlbumToGraphQL(albumModel)
				edges = append(edges, &model.AlbumEdge{
					Cursor: r.paginationHelper.EncodeCursor(albumID, time.Now(), i),
					Node:   albumGraphQL,
				})
			}
		}
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Albums completed - Count: %d, Duration: %v", len(edges), duration)

	return &model.AlbumConnection{
		TotalCount: int32(len(edges)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   nil,
			HasNextPage: false,
		},
	}, nil
}

// Album is the resolver for the album field.
func (r *queryResolver) Album(ctx context.Context, id string) (*model.Album, error) {
	start := time.Now()
	log.Printf("[QUERY] Album started - ID: %s", id)

	// 1. Check Redis cache first
	if cachedAlbum, err := r.repos.SpotifyCache.GetAlbum(ctx, id); err == nil && cachedAlbum != nil {
		log.Printf("[CACHE] Album cache hit - ID: %s", id)
		duration := time.Since(start)
		log.Printf("[QUERY] Album completed (CACHE) - ID: %s, Duration: %v", id, duration)
		return spotifyAlbumToGraphQL(cachedAlbum), nil
	}

	// 2. Fetch from Spotify API
	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	spotifyAlbum, err := r.spotifyServices.Album.GetAlbum(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] Album API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("album not found: %w", err)
	}

	// 3. Convert Spotify data to internal model
	albumModel := spotifyAPIAlbumToModel(spotifyAlbum)

	// 4. Cache in Redis
	if err := r.repos.SpotifyCache.SetAlbum(ctx, albumModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache album: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Album completed (API) - ID: %s, Duration: %v", id, duration)

	// 5. Convert to GraphQL and return
	return spotifyAlbumToGraphQL(albumModel), nil
}

// AlbumDetails is the resolver for the albumDetails field.
func (r *queryResolver) AlbumDetails(ctx context.Context, id string) (*model.AlbumDetails, error) {
	start := time.Now()
	log.Printf("[QUERY] AlbumDetails started - ID: %s", id)

	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	// Fetch album from Spotify API
	spotifyAlbum, err := r.spotifyServices.Album.GetAlbum(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] AlbumDetails API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("album not found: %w", err)
	}

	// Fetch album tracks
	tracksPage, err := r.spotifyServices.Album.GetAlbumTracks(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] AlbumTracks API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("failed to get album tracks: %w", err)
	}

	// Convert to AlbumDetails
	albumDetails := spotifyAPIAlbumToAlbumDetails(spotifyAlbum, tracksPage.Tracks)

	// Cache the main album
	albumModel := spotifyAPIAlbumToModel(spotifyAlbum)
	if err := r.repos.SpotifyCache.SetAlbum(ctx, albumModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache album: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] AlbumDetails completed - ID: %s, Duration: %v", id, duration)

	return albumDetails, nil
}

// Artist is the resolver for the artist field.
func (r *queryResolver) Artist(ctx context.Context, id string) (*model.Artist, error) {
	start := time.Now()
	log.Printf("[QUERY] Artist started - ID: %s", id)

	// 1. Check Redis cache first
	if cachedArtist, err := r.repos.SpotifyCache.GetArtist(ctx, id); err == nil && cachedArtist != nil {
		log.Printf("[CACHE] Artist cache hit - ID: %s", id)
		duration := time.Since(start)
		log.Printf("[QUERY] Artist completed (CACHE) - ID: %s, Duration: %v", id, duration)
		return spotifyArtistToGraphQL(cachedArtist), nil
	}

	// 2. Fetch from Spotify API
	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	spotifyArtist, err := r.spotifyServices.Artist.GetArtist(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] Artist API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("artist not found: %w", err)
	}

	// 3. Convert Spotify data to internal model
	artistModel := spotifyAPIArtistToModel(spotifyArtist)

	// 4. Cache in Redis
	if err := r.repos.SpotifyCache.SetArtist(ctx, artistModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache artist: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Artist completed (API) - ID: %s, Duration: %v", id, duration)

	// 5. Convert to GraphQL and return
	return spotifyArtistToGraphQL(artistModel), nil
}

// ArtistDetails is the resolver for the artistDetails field.
func (r *queryResolver) ArtistDetails(ctx context.Context, id string) (*model.ArtistDetails, error) {
	start := time.Now()
	log.Printf("[QUERY] ArtistDetails started - ID: %s", id)

	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	// Fetch artist from Spotify API
	spotifyArtist, err := r.spotifyServices.Artist.GetArtist(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] ArtistDetails API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("artist not found: %w", err)
	}

	// Fetch artist's albums
	albumTypes := []spotifyapi.AlbumType{spotifyapi.AlbumTypeAlbum, spotifyapi.AlbumTypeSingle}
	albumsPage, err := r.spotifyServices.Artist.GetArtistAlbums(ctx, spotifyapi.ID(id), albumTypes, spotifyapi.Limit(20))
	if err != nil {
		log.Printf("[SPOTIFY] ArtistAlbums API error - ID: %s, Error: %v", id, err)
		// Continue without albums rather than failing
		albumsPage = &spotifyapi.SimpleAlbumPage{}
	}

	// Fetch artist's top tracks
	topTracks, err := r.spotifyServices.Artist.GetArtistTopTracks(ctx, spotifyapi.ID(id), "US")
	if err != nil {
		log.Printf("[SPOTIFY] ArtistTopTracks API error - ID: %s, Error: %v", id, err)
		// Continue without top tracks rather than failing
		topTracks = []spotifyapi.FullTrack{}
	}

	// Convert to ArtistDetails
	artistDetails := spotifyAPIArtistToArtistDetails(spotifyArtist, albumsPage.Albums, topTracks)

	// Cache the main artist
	artistModel := spotifyAPIArtistToModel(spotifyArtist)
	if err := r.repos.SpotifyCache.SetArtist(ctx, artistModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache artist: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] ArtistDetails completed - ID: %s, Duration: %v", id, duration)

	return artistDetails, nil
}

// Tracks is the resolver for the tracks field.
func (r *queryResolver) Tracks(ctx context.Context, first *int32, after *string) (*model.TrackConnection, error) {
	start := time.Now()
	log.Printf("[QUERY] Tracks started")

	// Extract UserID from Context (must be authenticated for user-specific data)
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		log.Printf("[QUERY] Tracks - User not authenticated, returning empty connection")
		return &model.TrackConnection{
			TotalCount: 0,
			Edges:      []*model.TrackEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	currentUserID := raw.(string)
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Try to get user's saved tracks from cache
	cachedData, err := r.repos.SpotifyCache.GetUserData(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] Tracks - Cache error: %v", err)
		// Return empty list instead of error for better UX
		return &model.TrackConnection{
			TotalCount: 0,
			Edges:      []*model.TrackEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	if cachedData == nil || len(cachedData.SavedTracks) == 0 {
		log.Printf("[QUERY] Tracks - No saved tracks for user")
		return &model.TrackConnection{
			TotalCount: 0,
			Edges:      []*model.TrackEdge{},
			PageInfo: &model.PageInfo{
				EndCursor:   nil,
				HasNextPage: false,
			},
		}, nil
	}

	// Get track details from cache or Spotify API
	var edges []*model.TrackEdge
	limit := 20
	if first != nil {
		limit = int(*first)
	}

	trackIDs := cachedData.SavedTracks
	if len(trackIDs) > limit {
		trackIDs = trackIDs[:limit]
	}

	for i, trackID := range trackIDs {
		// Try cache first
		cachedTrack, err := r.repos.SpotifyCache.GetTrack(ctx, trackID)
		if err == nil && cachedTrack != nil {
			trackGraphQL := spotifyTrackToGraphQL(cachedTrack)
			edges = append(edges, &model.TrackEdge{
				Cursor: r.paginationHelper.EncodeCursor(trackID, time.Now(), i),
				Node:   trackGraphQL,
			})
			continue
		}

		// Fallback to Spotify API
		if r.spotifyServices != nil {
			spotifyTrack, err := r.spotifyServices.Track.GetTrack(ctx, spotifyapi.ID(trackID))
			if err == nil {
				trackModel := spotifyAPITrackToModel(spotifyTrack)
				// Cache the result
				if err := r.repos.SpotifyCache.SetTrack(ctx, trackModel); err != nil {
					log.Printf("[CACHE] Warning: Failed to cache track: %v", err)
				}
				trackGraphQL := spotifyTrackToGraphQL(trackModel)
				edges = append(edges, &model.TrackEdge{
					Cursor: r.paginationHelper.EncodeCursor(trackID, time.Now(), i),
					Node:   trackGraphQL,
				})
			}
		}
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Tracks completed - Count: %d, Duration: %v", len(edges), duration)

	return &model.TrackConnection{
		TotalCount: int32(len(edges)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   nil,
			HasNextPage: false,
		},
	}, nil
}

// Track is the resolver for the track field.
func (r *queryResolver) Track(ctx context.Context, id string) (*model.Track, error) {
	start := time.Now()
	log.Printf("[QUERY] Track started - ID: %s", id)

	// 1. Check Redis cache first
	if cachedTrack, err := r.repos.SpotifyCache.GetTrack(ctx, id); err == nil && cachedTrack != nil {
		log.Printf("[CACHE] Track cache hit - ID: %s", id)
		duration := time.Since(start)
		log.Printf("[QUERY] Track completed (CACHE) - ID: %s, Duration: %v", id, duration)
		return spotifyTrackToGraphQL(cachedTrack), nil
	}

	// 2. Fetch from Spotify API
	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	spotifyTrack, err := r.spotifyServices.Track.GetTrack(ctx, spotifyapi.ID(id))
	if err != nil {
		log.Printf("[SPOTIFY] Track API error - ID: %s, Error: %v", id, err)
		return nil, fmt.Errorf("track not found: %w", err)
	}

	// 3. Convert Spotify data to internal model
	trackModel := spotifyAPITrackToModel(spotifyTrack)

	// 4. Cache in Redis
	if err := r.repos.SpotifyCache.SetTrack(ctx, trackModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache track: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] Track completed (API) - ID: %s, Duration: %v", id, duration)

	// 5. Convert to GraphQL and return
	return spotifyTrackToGraphQL(trackModel), nil
}

// Playlists is the resolver for the playlists field.
func (r *queryResolver) Playlists(ctx context.Context, first *int32, after *string) (*model.PlaylistConnection, error) {
	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Use pagination helper for improved cursor-based pagination
	playlists, hasNextPage, err := r.paginationHelper.GetPlaylistsWithCursor(ctx, limit, after)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch playlists: %w", err)
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.PlaylistEdge, len(playlists))
	for i, playlist := range playlists {
		edges[i] = &model.PlaylistEdge{
			Cursor: r.paginationHelper.EncodeCursor(playlist.ID.String(), playlist.CreatedAt, i),
			Node:   dbPlaylistToGraphQL(playlist),
		}
	}

	// Get total count for the connection
	totalCount := len(edges) // Simplified total count using current page size

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	return &model.PlaylistConnection{
		TotalCount: safeLenToInt32(totalCount),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}

// RecentlyPlayed is the resolver for the recentlyPlayed field.
func (r *queryResolver) RecentlyPlayed(ctx context.Context, limit *int32) ([]*model.Track, error) {
	start := time.Now()
	// Extract UserID from Context (must be authenticated)
	raw := ctx.Value(UserIDKey)
	if raw == nil {
		return nil, fmt.Errorf("unauthenticated")
	}
	currentUserID := raw.(string)
	log.Printf("[QUERY] RecentlyPlayed - User: %s", currentUserID)

	// Parse user ID
	userID, err := uuid.Parse(currentUserID)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	// Set default limit
	trackLimit := 20
	if limit != nil {
		trackLimit = int(*limit)
	}

	// Try to get cached user data first
	cachedData, err := r.repos.SpotifyCache.GetUserData(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] RecentlyPlayed - Cache error: %v", err)
		// Continue to try legacy cache
	}

	// If we have cached user data with recently played tracks
	if cachedData != nil && len(cachedData.RecentlyPlayed) > 0 {
		var tracks []*model.Track
		recentlyPlayed := cachedData.RecentlyPlayed
		if len(recentlyPlayed) > trackLimit {
			recentlyPlayed = recentlyPlayed[:trackLimit]
		}

		for _, track := range recentlyPlayed {
			trackGraphQL := spotifyTrackToGraphQL(&track)
			tracks = append(tracks, trackGraphQL)
		}

		duration := time.Since(start)
		log.Printf("[QUERY] RecentlyPlayed completed (NEW CACHE) - Count: %d, Duration: %v", len(tracks), duration)
		return tracks, nil
	}

	// Fallback to legacy music cache
	legacyCachedData, err := r.repos.MusicCache.GetUserMusicData(ctx, userID)
	if err != nil {
		log.Printf("[QUERY] RecentlyPlayed - Legacy cache error: %v", err)
		// Return empty list instead of error for better UX
		return []*model.Track{}, nil
	}

	if legacyCachedData == nil {
		// No cached data, return empty list
		log.Printf("[QUERY] RecentlyPlayed - No cached data for user")
		return []*model.Track{}, nil
	}

	// Try to cast to legacy MusicData type
	if musicData, ok := legacyCachedData.(*redisrepo.MusicData); ok && len(musicData.RecentlyPlayed) > 0 {
		var tracks []*model.Track
		recentlyPlayed := musicData.RecentlyPlayed
		if len(recentlyPlayed) > trackLimit {
			recentlyPlayed = recentlyPlayed[:trackLimit]
		}

		for _, track := range recentlyPlayed {
			trackGraphQL := spotifyTrackToGraphQL(track)
			tracks = append(tracks, trackGraphQL)
		}

		duration := time.Since(start)
		log.Printf("[QUERY] RecentlyPlayed completed (LEGACY CACHE) - Count: %d, Duration: %v", len(tracks), duration)
		return tracks, nil
	}

	// No data available
	duration := time.Since(start)
	log.Printf("[QUERY] RecentlyPlayed completed (NO DATA) - Duration: %v", duration)
	return []*model.Track{}, nil
}

// SearchAlbums is the resolver for the searchAlbums field.
func (r *queryResolver) SearchAlbums(ctx context.Context, input model.AlbumSearchInput) ([]*model.AlbumSearchResult, error) {
	start := time.Now()
	limit := 20
	if input.Limit != nil {
		limit = int(*input.Limit)
	}
	log.Printf("[QUERY] SearchAlbums started - Query: '%s', Limit: %d, Source: %s", input.Query, limit, input.Source)

	if r.spotifyServices == nil {
		log.Printf("[QUERY] SearchAlbums failed - Spotify service not available")
		return nil, fmt.Errorf("Spotify service not available")
	}

	// Check cache first
	cacheKey := fmt.Sprintf("%s:%d", input.Query, limit)
	log.Printf("[CACHE] Checking cache for albums - Key: %s", cacheKey)

	if cachedData, err := r.repos.MusicCache.GetSearchResults(ctx, cacheKey, "albums"); err == nil && cachedData != nil {
		if searchData, ok := cachedData.(*redisrepo.SearchCacheData); ok {
			if results, ok := searchData.Results.([]*model.AlbumSearchResult); ok {
				duration := time.Since(start)
				log.Printf("[QUERY] SearchAlbums completed (CACHE HIT) - Query: '%s', Count: %d, Duration: %v", input.Query, len(results), duration)
				return results, nil
			}
		}
	}
	log.Printf("[CACHE] Cache miss for albums - Key: %s", cacheKey)

	// Use the new Spotify client to search for albums
	log.Printf("[SPOTIFY] Calling Spotify API for albums - Query: '%s', Limit: %d", input.Query, limit)
	results, err := r.spotifyServices.Search.SearchAlbums(ctx, input.Query,
		spotifyapi.Limit(limit))
	if err != nil {
		log.Printf("[SPOTIFY] SearchAlbums failed - API error: %v", err)
		return nil, fmt.Errorf("failed to search albums: %w", err)
	}

	log.Printf("[SPOTIFY] Spotify API response received - Albums found: %d", len(results.Albums.Albums))

	// Convert Spotify results to GraphQL model
	var albumResults []*model.AlbumSearchResult
	if results.Albums != nil {
		for _, album := range results.Albums.Albums {
			// Convert artists
			var artists []*model.ArtistSearchResult
			for _, artist := range album.Artists {
				artists = append(artists, &model.ArtistSearchResult{
					ID:             string(artist.ID),
					Name:           artist.Name,
					ExternalSource: model.ExternalSourceSpotify,
				})
			}

			// Convert release date
			var releaseDate *string
			if album.ReleaseDate != "" {
				releaseDate = &album.ReleaseDate
			}

			// Convert cover image
			var coverImage *string
			if len(album.Images) > 0 {
				coverImage = &album.Images[0].URL
			}

			albumResults = append(albumResults, &model.AlbumSearchResult{
				ID:             string(album.ID),
				Title:          album.Name,
				Artist:         artists,
				ReleaseDate:    releaseDate,
				CoverImage:     coverImage,
				ExternalSource: model.ExternalSourceSpotify,
			})
		}
	}

	// Cache the results for faster future searches
	log.Printf("[CACHE] Caching album search results - Key: %s, Count: %d", cacheKey, len(albumResults))
	if err := r.repos.MusicCache.SetSearchResults(ctx, cacheKey, "albums", albumResults); err != nil {
		// Log the error but don't fail the request
		log.Printf("[CACHE] Warning: Failed to cache album search results: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] SearchAlbums completed (SPOTIFY API) - Query: '%s', Count: %d, Duration: %v", input.Query, len(albumResults), duration)

	return albumResults, nil
}

// SearchArtists is the resolver for the searchArtists field.
func (r *queryResolver) SearchArtists(ctx context.Context, input model.ArtistSearchInput) ([]*model.ArtistSearchResult, error) {
	start := time.Now()
	limit := 20
	if input.Limit != nil {
		limit = int(*input.Limit)
	}
	log.Printf("[QUERY] SearchArtists started - Query: '%s', Limit: %d, Source: %s", input.Query, limit, input.Source)

	if r.spotifyServices == nil {
		log.Printf("[QUERY] SearchArtists failed - Spotify service not available")
		return nil, fmt.Errorf("spotify service not available")
	}

	// Check cache first
	cacheKey := fmt.Sprintf("%s:%d", input.Query, limit)
	log.Printf("[CACHE] Checking cache for artists - Key: %s", cacheKey)

	if cachedData, err := r.repos.MusicCache.GetSearchResults(ctx, cacheKey, "artists"); err == nil && cachedData != nil {
		if searchData, ok := cachedData.(*redisrepo.SearchCacheData); ok {
			if results, ok := searchData.Results.([]*model.ArtistSearchResult); ok {
				duration := time.Since(start)
				log.Printf("[QUERY] SearchArtists completed (CACHE HIT) - Query: '%s', Count: %d, Duration: %v", input.Query, len(results), duration)
				return results, nil
			}
		}
	}
	log.Printf("[CACHE] Cache miss for artists - Key: %s", cacheKey)

	// Use the new Spotify client to search for artists
	log.Printf("[SPOTIFY] Calling Spotify API for artists - Query: '%s', Limit: %d", input.Query, limit)
	results, err := r.spotifyServices.Search.SearchArtists(ctx, input.Query,
		spotifyapi.Limit(limit))
	if err != nil {
		log.Printf("[SPOTIFY] SearchArtists failed - API error: %v", err)
		return nil, fmt.Errorf("failed to search artists: %w", err)
	}

	log.Printf("[SPOTIFY] Spotify API response received - Artists found: %d", len(results.Artists.Artists))

	// Convert Spotify results to GraphQL model
	var artistResults []*model.ArtistSearchResult
	if results.Artists != nil {
		for _, artist := range results.Artists.Artists {
			artistResults = append(artistResults, &model.ArtistSearchResult{
				ID:             string(artist.ID),
				Name:           artist.Name,
				ExternalSource: model.ExternalSourceSpotify,
			})
		}
	}

	// Cache the results for faster future searches
	log.Printf("[CACHE] Caching artist search results - Key: %s, Count: %d", cacheKey, len(artistResults))
	if err := r.repos.MusicCache.SetSearchResults(ctx, cacheKey, "artists", artistResults); err != nil {
		// Log the error but don't fail the request
		log.Printf("[CACHE] Warning: Failed to cache artist search results: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] SearchArtists completed (SPOTIFY API) - Query: '%s', Count: %d, Duration: %v", input.Query, len(artistResults), duration)

	return artistResults, nil
}

// SearchTracks is the resolver for the searchTracks field.
func (r *queryResolver) SearchTracks(ctx context.Context, input model.TrackSearchInput) ([]*model.TrackSearchResult, error) {
	start := time.Now()
	limit := 20
	if input.Limit != nil {
		limit = int(*input.Limit)
	}
	log.Printf("[QUERY] SearchTracks started - Query: '%s', Limit: %d, Source: %s", input.Query, limit, input.Source)

	if r.spotifyServices == nil {
		log.Printf("[QUERY] SearchTracks failed - Spotify service not available")
		return nil, fmt.Errorf("spotify service not available")
	}

	// Check cache first
	cacheKey := fmt.Sprintf("%s:%d", input.Query, limit)
	log.Printf("[CACHE] Checking cache for tracks - Key: %s", cacheKey)

	if cachedData, err := r.repos.MusicCache.GetSearchResults(ctx, cacheKey, "tracks"); err == nil && cachedData != nil {
		if searchData, ok := cachedData.(*redisrepo.SearchCacheData); ok {
			if results, ok := searchData.Results.([]*model.TrackSearchResult); ok {
				duration := time.Since(start)
				log.Printf("[QUERY] SearchTracks completed (CACHE HIT) - Query: '%s', Count: %d, Duration: %v", input.Query, len(results), duration)
				return results, nil
			}
		}
	}
	log.Printf("[CACHE] Cache miss for tracks - Key: %s", cacheKey)

	// Use the new Spotify client to search for tracks
	log.Printf("[SPOTIFY] Calling Spotify API for tracks - Query: '%s', Limit: %d", input.Query, limit)
	results, err := r.spotifyServices.Search.SearchTracks(ctx, input.Query,
		spotifyapi.Limit(limit))
	if err != nil {
		log.Printf("[SPOTIFY] SearchTracks failed - API error: %v", err)
		return nil, fmt.Errorf("failed to search tracks: %w", err)
	}

	log.Printf("[SPOTIFY] Spotify API response received - Tracks found: %d", len(results.Tracks.Tracks))

	// Convert Spotify results to GraphQL model
	var trackResults []*model.TrackSearchResult
	if results.Tracks != nil {
		for _, track := range results.Tracks.Tracks {
			// Convert artists
			var artists []*model.ArtistSearchResult
			for _, artist := range track.Artists {
				artists = append(artists, &model.ArtistSearchResult{
					ID:             string(artist.ID),
					Name:           artist.Name,
					ExternalSource: model.ExternalSourceSpotify,
				})
			}

			// Convert album if available
			var album *model.AlbumSearchResult
			if len(track.Album.Artists) > 0 {
				var albumArtists []*model.ArtistSearchResult
				for _, artist := range track.Album.Artists {
					albumArtists = append(albumArtists, &model.ArtistSearchResult{
						ID:             string(artist.ID),
						Name:           artist.Name,
						ExternalSource: model.ExternalSourceSpotify,
					})
				}

				var coverImage *string
				if len(track.Album.Images) > 0 {
					coverImage = &track.Album.Images[0].URL
				}

				var releaseDate *string
				if track.Album.ReleaseDate != "" {
					releaseDate = &track.Album.ReleaseDate
				}

				album = &model.AlbumSearchResult{
					ID:             string(track.Album.ID),
					Title:          track.Album.Name,
					Artist:         albumArtists,
					ReleaseDate:    releaseDate,
					CoverImage:     coverImage,
					ExternalSource: model.ExternalSourceSpotify,
				}
			}

			var duration *int32
			if track.Duration > 0 {
				durationSeconds := int32(track.Duration / 1000) // Convert ms to seconds
				duration = &durationSeconds
			}

			var trackNumber *int32
			if track.TrackNumber > 0 {
				trackNum := int32(track.TrackNumber)
				trackNumber = &trackNum
			}

			trackResults = append(trackResults, &model.TrackSearchResult{
				ID:             string(track.ID),
				Title:          track.Name,
				Duration:       duration,
				TrackNumber:    trackNumber,
				Album:          album,
				Artists:        artists,
				ExternalSource: model.ExternalSourceSpotify,
			})
		}
	}

	// Cache the results for faster future searches
	log.Printf("[CACHE] Caching track search results - Key: %s, Count: %d", cacheKey, len(trackResults))
	if err := r.repos.MusicCache.SetSearchResults(ctx, cacheKey, "tracks", trackResults); err != nil {
		// Log the error but don't fail the request
		log.Printf("[CACHE] Warning: Failed to cache track search results: %v", err)
	}

	duration := time.Since(start)
	log.Printf("[QUERY] SearchTracks completed (SPOTIFY API) - Query: '%s', Count: %d, Duration: %v", input.Query, len(trackResults), duration)

	return trackResults, nil
}

// SpotifyPlaylists is the resolver for the spotifyPlaylists field.
func (r *queryResolver) SpotifyPlaylists(ctx context.Context, input *model.SpotifyPlaylistsInput) (*model.SpotifyPlaylistConnection, error) {
	// Get current user from context
	userIDStr, ok := ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	if r.SpotifyPlaylistService == nil {
		return nil, fmt.Errorf("spotify service not available")
	}

	// Set defaults if input is nil
	limit := 20
	offset := 0
	if input != nil {
		if input.Limit != nil {
			limit = int(*input.Limit)
		}
		if input.Offset != nil {
			offset = int(*input.Offset)
		}
	}

	// Get playlists with pagination
	playlists, totalCount, err := r.SpotifyPlaylistService.GetUserSpotifyPlaylists(ctx, userID, limit, offset)
	if err != nil {
		return nil, fmt.Errorf("failed to get Spotify playlists: %w", err)
	}

	// Convert to GraphQL model
	var gqlPlaylists []*model.SpotifyPlaylist
	for _, playlist := range playlists {
		gqlPlaylist := &model.SpotifyPlaylist{
			ID:          playlist.ID,
			Name:        playlist.Name,
			Description: &playlist.Description,
			TrackCount:  int32(playlist.TrackCount),
			IsPublic:    playlist.IsPublic,
		}
		if playlist.Image != "" {
			gqlPlaylist.Image = &playlist.Image
		}
		gqlPlaylists = append(gqlPlaylists, gqlPlaylist)
	}

	hasNextPage := offset+limit < totalCount

	return &model.SpotifyPlaylistConnection{
		Playlists:   gqlPlaylists,
		TotalCount:  int32(totalCount),
		HasNextPage: hasNextPage,
	}, nil
}

// SpotifyAuthURL is the resolver for the spotifyAuthURL field.
func (r *queryResolver) SpotifyAuthURL(ctx context.Context) (*model.SpotifyAuthURL, error) {
	// Get current user from context
	userIDStr, ok := ForContext(ctx)
	if !ok {
		return nil, fmt.Errorf("user not authenticated")
	}

	userID, err := uuid.Parse(userIDStr)
	if err != nil {
		return nil, fmt.Errorf("invalid user ID")
	}

	if r.SpotifyAuthService == nil {
		return nil, fmt.Errorf("spotify auth service not available")
	}

	// Generate auth URL
	url, state, err := r.SpotifyAuthService.GenerateAuthURL(userID)
	if err != nil {
		return nil, fmt.Errorf("failed to generate auth URL: %w", err)
	}

	return &model.SpotifyAuthURL{
		URL:   url,
		State: state,
	}, nil
}

// ReviewAdded is the resolver for the reviewAdded field.
func (r *subscriptionResolver) ReviewAdded(ctx context.Context, albumID string) (<-chan *model.Review, error) {
	// Subscribe to review updates for the specified album using subscription manager
	reviewChan, cleanup := r.subscriptionMgr.Subscribe(ctx, albumID)

	// The cleanup function will be called automatically when the context is cancelled
	_ = cleanup

	return reviewChan, nil
}

// Album is the resolver for the album field.
func (r *trackResolver) Album(ctx context.Context, obj *model.Track) (*model.Album, error) {
	start := time.Now()
	log.Printf("[RESOLVER] Track.Album started - TrackID: %s", obj.ID)

	// First try to get the track from cache which should have album info
	if cachedTrack, err := r.repos.SpotifyCache.GetTrack(ctx, obj.ID); err == nil && cachedTrack != nil {
		albumGraphQL := spotifyAlbumToGraphQL(&cachedTrack.Album)
		if albumGraphQL != nil {
			duration := time.Since(start)
			log.Printf("[RESOLVER] Track.Album completed (CACHE) - TrackID: %s, AlbumID: %s, Duration: %v", obj.ID, albumGraphQL.ID, duration)
			return albumGraphQL, nil
		}
	}

	// If not in cache or cache doesn't have album info, fetch from Spotify API
	if r.spotifyServices == nil {
		return nil, fmt.Errorf("Spotify service not available")
	}

	spotifyTrack, err := r.spotifyServices.Track.GetTrack(ctx, spotifyapi.ID(obj.ID))
	if err != nil {
		log.Printf("[RESOLVER] Track.Album - Spotify API error: %v", err)
		return nil, fmt.Errorf("failed to get track album: %w", err)
	}

	// Convert and cache the track
	trackModel := spotifyAPITrackToModel(spotifyTrack)
	if err := r.repos.SpotifyCache.SetTrack(ctx, trackModel); err != nil {
		log.Printf("[CACHE] Warning: Failed to cache track: %v", err)
	}

	// Return the album from the track
	albumGraphQL := spotifyAlbumToGraphQL(&trackModel.Album)

	duration := time.Since(start)
	log.Printf("[RESOLVER] Track.Album completed (API) - TrackID: %s, AlbumID: %s, Duration: %v", obj.ID, albumGraphQL.ID, duration)

	return albumGraphQL, nil
}

// Artist returns ArtistResolver implementation.
func (r *Resolver) Artist() ArtistResolver { return &artistResolver{r} }

// Mutation returns MutationResolver implementation.
func (r *Resolver) Mutation() MutationResolver { return &mutationResolver{r} }

// Playlist returns PlaylistResolver implementation.
func (r *Resolver) Playlist() PlaylistResolver { return &playlistResolver{r} }

// Query returns QueryResolver implementation.
func (r *Resolver) Query() QueryResolver { return &queryResolver{r} }

// Subscription returns SubscriptionResolver implementation.
func (r *Resolver) Subscription() SubscriptionResolver { return &subscriptionResolver{r} }

// Track returns TrackResolver implementation.
func (r *Resolver) Track() TrackResolver { return &trackResolver{r} }

// AlbumDetails returns AlbumDetailsResolver implementation.
func (r *Resolver) AlbumDetails() AlbumDetailsResolver { return &albumDetailsResolver{r} }

type artistResolver struct{ *Resolver }
type mutationResolver struct{ *Resolver }
type playlistResolver struct{ *Resolver }
type queryResolver struct{ *Resolver }
type subscriptionResolver struct{ *Resolver }
type trackResolver struct{ *Resolver }
type albumDetailsResolver struct{ *Resolver }

// AlbumDetailsResolver represents a resolver for the AlbumDetails type
type AlbumDetailsResolver interface {
	Reviews(ctx context.Context, obj *model.AlbumDetails, first *int32, after *string) (*model.ReviewConnection, error)
}

// Reviews is the resolver for the reviews field.
func (r *albumDetailsResolver) Reviews(ctx context.Context, obj *model.AlbumDetails, first *int32, after *string) (*model.ReviewConnection, error) {
	// In the new architecture, obj.ID is a Spotify ID, not a database UUID
	spotifyID := obj.ID

	// Set default limit
	limit := 10
	if first != nil {
		limit = int(*first)
	}

	// Get reviews for this Spotify album with pagination
	// Use GetBySpotifyID instead of GetByAlbumID since albums are now referenced by Spotify ID
	reviews, err := r.repos.Review.GetBySpotifyID(ctx, spotifyID, "album", limit+1, 0)
	if err != nil {
		log.Printf("[RESOLVER] AlbumDetails.Reviews failed - SpotifyID: %s, Error: %v", spotifyID, err)
		return nil, fmt.Errorf("failed to get album reviews: %w", err)
	}

	// Check if there's a next page
	hasNextPage := len(reviews) > limit
	if hasNextPage {
		reviews = reviews[:limit]
	}

	// Convert database models to GraphQL models and create edges
	edges := make([]*model.ReviewEdge, len(reviews))
	for i, review := range reviews {
		edges[i] = &model.ReviewEdge{
			Cursor: r.paginationHelper.EncodeCursor(review.ID.String(), review.CreatedAt, i),
			Node:   dbReviewToGraphQL(review),
		}
	}

	// Create page info
	var endCursor *string
	if len(edges) > 0 {
		endCursor = &edges[len(edges)-1].Cursor
	}

	log.Printf("[RESOLVER] AlbumDetails.Reviews completed - SpotifyID: %s, Count: %d", spotifyID, len(reviews))

	return &model.ReviewConnection{
		TotalCount: int32(len(reviews)),
		Edges:      edges,
		PageInfo: &model.PageInfo{
			EndCursor:   endCursor,
			HasNextPage: hasNextPage,
		},
	}, nil
}
